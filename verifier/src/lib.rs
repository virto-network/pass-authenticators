#![cfg_attr(not(any(feature = "std", test)), no_std)]

//! Verifies a WebAuthn response signature.
//!
//! This function validates the signature of a WebAuthn authentication response by:
//!
//! 1. Concatenating the `authenticator_data` and the hashed `client_data_json` to form the message.
//! 2. Verifying the `signature_der` against the message using the provided `credential_public_key_cbor`.
//!
//! The `credential_public_key_cbor` should be in COSE format and correspond to an ECDSA P-256 public key,
//! as specified in the WebAuthn standard.
//!
//! # Arguments
//!
//! * `authenticator_data` - The raw bytes of the authenticator data provided by the authenticator.
//! * `client_data_json` - The client data JSON.
//! * `signature_der` - The signature generated by the authenticator.
//! * `credential_public_key_cbor` - The public key in COSE format extracted from the authenticator's attestation data.
//!
//! # Returns
//!
//! * `true` if the signature is valid.
//! * `false` if the signature is invalid.
//!
//! # Example
//!
//! ```ignore
//! let authenticator_data = /* ... */;
//! let client_data_json = /* ... */;
//! let signature_der = /* ... */;
//! let credential_public_key_cbor = /* ... */;
//!
//! let is_valid = verify_webauthn_response(
//!     &authenticator_data,
//!     &client_data_json,
//!     &signature_der,
//!     &credential_public_key_cbor,
//! );
//!
//! assert!(is_valid);
//! ```
//!
//! # References
//!
//! * [Web Authentication: An API for accessing Public Key Credentials Level 2 - ยง7.2. Verifying an Authentication Assertion](https://www.w3.org/TR/webauthn/#sctn-verifying-assertion)
//! * "20. Using credentialPublicKey, verify that sig is a valid signature over the binary concatenation of authData and hash."
//! * <https://www.w3.org/TR/webauthn/#fig-signature>
//! * <https://www.w3.org/TR/webauthn/images/fido-signature-formats-figure2.svg>

extern crate alloc;
use p256::{
    ecdsa::{signature::Verifier, DerSignature, VerifyingKey},
    elliptic_curve::PublicKey,
    pkcs8::DecodePublicKey,
    NistP256,
};
use sha2::{Digest, Sha256};

#[derive(Debug)]
pub enum VerifyError {
    ExtractPublicKey,
    ParseSignature,
    VerifySignature,
}

pub fn webauthn_verify(
    authenticator_data: &[u8],
    client_data_json: &[u8],
    signature_der: &[u8],
    credential_public_key_der: &[u8],
) -> Result<(), VerifyError> {
    // Step 1: Compute the SHA-256 hash of the client data JSON
    let client_data_hash: [u8; 32] = Sha256::digest(client_data_json).into();

    // Step 2: Concatenate authenticator data and client data hash
    let message = vec![authenticator_data, &client_data_hash].concat();

    // Step 3: Extract public key from DER format
    let public_key: PublicKey<NistP256> =
        DecodePublicKey::from_public_key_der(credential_public_key_der)
            .map_err(|_| VerifyError::ExtractPublicKey)?;

    let verifying_key = VerifyingKey::from(public_key);

    // Step 4: Parse the DER signature
    let signature =
        DerSignature::try_from(signature_der).map_err(|_| VerifyError::ParseSignature)?;

    // Step 5: Verify the signature
    verifying_key
        .verify(&message, &signature)
        .map(|_| ())
        .map_err(|_| VerifyError::VerifySignature)
}

#[cfg(test)]
mod tests {
    use super::*;
    use coset::{
        iana::{Algorithm, EllipticCurve},
        CoseKeyBuilder,
    };
    use p256::ecdsa::{signature::Signer, Signature, SigningKey};
    use passkey_authenticator::public_key_der_from_cose_key;
    use rand::rngs::OsRng;
    use sha2::{Digest, Sha256};

    #[test]
    fn test_verify_webauthn_response_with_generated_data() {
        let authenticator_data = b"example authenticator data";
        let client_data_json = br#"{
            "challenge": "test-challenge",
            "origin": "https://example.com",
            "type": "webauthn.get"
        }"#;

        // Step 1: Generate a private key using the P-256 curve
        let private_key = SigningKey::random(&mut OsRng);
        let public_key = private_key.verifying_key().to_encoded_point(false); // Uncompressed point

        // Step 2: Extract the affine coordinates (x, y)
        // SAFETY: These unwraps are safe because the public_key above is not compressed (false
        // parameter) therefore x and y are guaranteed to contain values.
        let x = public_key.x().unwrap().as_slice().to_vec();
        let y = public_key.y().unwrap().as_slice().to_vec();

        // Step 3: Construct the COSE key pair
        let public_key_cose = CoseKeyBuilder::new_ec2_pub_key(EllipticCurve::P_256, x, y)
            .algorithm(Algorithm::ES256)
            .build();

        // Step 4: Convert to DER from COSE
        // TODO: Is this conversion from COSE really necessary? Or is it possible to build the DER key from
        // scratch using another library?
        let public_key_der = public_key_der_from_cose_key(&public_key_cose)
            .map_err(|_| VerifyError::ExtractPublicKey)
            .expect("Conversion from COSE to DER failed");

        // Step 5: Compute client_data_hash and message
        let client_data_hash = Sha256::digest(client_data_json);
        let mut message = Vec::with_capacity(authenticator_data.len() + client_data_hash.len());
        message.extend_from_slice(authenticator_data);
        message.extend_from_slice(&client_data_hash);

        // Step 6: Sign the message to get the signature in DER format
        // ? Should this be in COSE format? I couldn't get coset::CoseSign1 to work
        // ? https://github.com/google/coset/blob/main/examples/signature.rs
        // ? Check the above link for an example of how to sign a message in COSE format
        let signature: Signature = private_key.sign(&message);
        let signature_der = signature.to_der();

        // Step 7: Verify the signature
        webauthn_verify(
            authenticator_data,
            client_data_json,
            signature_der.as_bytes(),
            public_key_der.as_slice(),
        )
        .expect("Verifying signature failed");
    }

    #[test]
    fn test_verify_webauthn_response_with_invalid_signature() {
        let authenticator_data = b"example authenticator data";
        let client_data_json = br#"{
            "challenge": "test-challenge",
            "origin": "https://example.com",
            "type": "webauthn.get"
        }"#;

        // Step 1: Generate a private key using the P-256 curve
        let private_key = SigningKey::random(&mut OsRng);
        let public_key = private_key.verifying_key().to_encoded_point(false); // Uncompressed point

        // Step 2: Extract the affine coordinates (x, y)
        let x = public_key.x().unwrap().as_slice().to_vec();
        let y = public_key.y().unwrap().as_slice().to_vec();

        // Step 3: Construct the COSE key pair
        let public_key_cose = CoseKeyBuilder::new_ec2_pub_key(EllipticCurve::P_256, x, y)
            .algorithm(Algorithm::ES256)
            .build();

        // Step 4: Convert to DER from COSE
        // TODO: Is this conversion from COSE really necessary? Or is it possible to build the DER key from
        // scratch using another library?
        let public_key_der = public_key_der_from_cose_key(&public_key_cose)
            .map_err(|_| VerifyError::ExtractPublicKey)
            .expect("Conversion from COSE to DER failed");

        // Step 5: Compute client_data_hash and message
        let client_data_hash = Sha256::digest(client_data_json);
        let mut message = Vec::with_capacity(authenticator_data.len() + client_data_hash.len());
        message.extend_from_slice(authenticator_data);
        message.extend_from_slice(&client_data_hash);

        // Step 6: Sign the message to get the signature in DER format
        let signature: Signature = private_key.sign(&message);
        let signature_der = signature.to_der();

        // Step 7: Tamper with the signature to make it invalid
        let mut tampered_signature_der = signature_der.as_bytes().to_vec();
        tampered_signature_der[0] ^= 0xFF; // Flip some bits

        // Step 8: Verify the signature (should fail)
        if let Ok(()) = webauthn_verify(
            authenticator_data,
            client_data_json,
            &tampered_signature_der,
            public_key_der.as_slice(),
        ) {
            assert!(
                false,
                "The signature verification should fail with an invalid signature."
            );
        }
    }
}
