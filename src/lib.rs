/// Verifies a WebAuthn response signature.
///
/// This function validates the signature of a WebAuthn authentication response by:
///
/// 1. Concatenating the `authenticator_data` and the hashed `client_data_json` to form the message.
/// 2. Verifying the `signature_der` against the message using the provided `credential_public_key_cbor`.
///
/// The `credential_public_key_cbor` should be in COSE format and correspond to an ECDSA P-256 public key,
/// as specified in the WebAuthn standard.
///
/// # Arguments
///
/// * `authenticator_data` - The raw bytes of the authenticator data provided by the authenticator.
/// * `client_data_json` - The client data JSON.
/// * `signature_der` - The signature generated by the authenticator.
/// * `credential_public_key_cbor` - The public key in COSE format extracted from the authenticator's attestation data.
///
/// # Returns
///
/// * `true` if the signature is valid.
/// * `false` if the signature is invalid.
///
/// # Example
///
/// ```ignore
/// let authenticator_data = /* ... */;
/// let client_data_json = /* ... */;
/// let signature_der = /* ... */;
/// let credential_public_key_cbor = /* ... */;
///
/// let is_valid = verify_webauthn_response(
///     &authenticator_data,
///     &client_data_hash,
///     &signature_der,
///     &credential_public_key_cbor,
/// );
///
/// assert!(is_valid);
/// ```
/// # References
///
/// * [Web Authentication: An API for accessing Public Key Credentials Level 2 - ยง7.2. Verifying an Authentication Assertion](https://www.w3.org/TR/webauthn/#sctn-verifying-assertion)
/// * "20. Using credentialPublicKey, verify that sig is a valid signature over the binary concatenation of authData and hash."
/// * https://www.w3.org/TR/webauthn/#fig-signature
/// * https://www.w3.org/TR/webauthn/images/fido-signature-formats-figure2.svg
///
use coset::{CborSerializable, CoseKey};
use p256::ecdsa::VerifyingKey;
use p256::ecdsa::{signature::Verifier, Signature};
use p256::elliptic_curve::PublicKey;
use p256::pkcs8::DecodePublicKey;
use p256::NistP256;
use sha2::{Digest, Sha256};

use passkey::authenticator;

pub fn verify_webauthn_response(
    authenticator_data: &[u8],
    client_data_json: &[u8],
    signature_der: &[u8],
    credential_public_key_cbor: &[u8],
) -> bool {
    // Step 1: Compute the SHA-256 hash of the client data JSON
    let client_data_hash: [u8; 32] = Sha256::digest(client_data_json).into();

    // Step 2: Concatenate authenticator data and client data hash
    let mut message = Vec::with_capacity(authenticator_data.len() + client_data_hash.len());
    message.extend_from_slice(authenticator_data);
    message.extend_from_slice(&client_data_hash);

    // Step 3: Parse the COSE public key, convert it to DER format, and parse it
    let public_key_cose =
        CoseKey::from_slice(credential_public_key_cbor).expect("Failed to parse COSE public key");
    let public_key_der = authenticator::public_key_der_from_cose_key(&public_key_cose)
        .expect("Failed to convert COSE key to DER format");
    let public_key = PublicKey::<NistP256>::from_public_key_der(&public_key_der)
        .expect("Failed to parse public key DER");
    let verifying_key = VerifyingKey::from(public_key);

    // Step 4: Parse the DER signature
    let signature = Signature::from_der(signature_der).expect("Failed to parse signature DER");

    // Print all public keys
    println!("Public Key COSE: {:?}", public_key_cose);
    println!("Public Key DER: {:?}", public_key_der);
    println!("Verifying Key: {:?}", verifying_key);

    // Print all signatures
    println!("Signature DER: {:?}", signature_der);
    println!("Signature: {:?}", signature);

    // Step 5: Verify the signature
    verifying_key
        .verify(&message, &signature)
        .expect("Signature verification failed");

    println!("Signature verification succeeded");

    true
}

// #[cfg(test)]
// mod tests {
//     use super::*;
//     use ring::digest::SHA256;
//     use ring::rand::SystemRandom;
//     use ring::signature::{EcdsaKeyPair, KeyPair, ECDSA_P256_SHA256_FIXED_SIGNING};

//     #[test]
//     fn test_verify_webauthn_response_valid() {
//         let rng = SystemRandom::new();

//         // Generate ECDSA P-256 key pair
//         let pkcs8_bytes = EcdsaKeyPair::generate_pkcs8(&ECDSA_P256_SHA256_FIXED_SIGNING, &rng)
//             .expect("Failed to generate key pair");
//         let key_pair =
//             EcdsaKeyPair::from_pkcs8(&ECDSA_P256_SHA256_FIXED_SIGNING, pkcs8_bytes.as_ref(), &rng)
//                 .expect("Failed to parse key pair");

//         // Extract public key in DER format
//         let public_key_der = key_pair.public_key().as_ref();

//         // Sample authenticator data
//         let authenticator_data = b"example authenticator data";

//         // Sample client data JSON
//         let client_data_json = br#"{
//             "challenge": "test-challenge",
//             "origin": "https://example.com",
//             "type": "webauthn.get"
//         }"#;

//         // Compute client data hash
//         let client_data_hash = ring::digest::digest(&SHA256, client_data_json);

//         // Concatenate authenticator data and client data hash
//         let mut message = Vec::new();
//         message.extend_from_slice(authenticator_data);
//         message.extend_from_slice(client_data_hash.as_ref());

//         // Sign the message
//         let signature = key_pair
//             .sign(&rng, &message)
//             .expect("Failed to sign message");

//         // Verify the signature
//         let is_valid = verify_webauthn_response(
//             authenticator_data,
//             client_data_json.as_ref(),
//             signature.as_ref(),
//             public_key_der,
//         );

//         assert!(
//             is_valid,
//             "The signature should be valid with the generated sample data."
//         );
//     }

//     #[test]
//     fn test_verify_webauthn_response_invalid() {
//         let rng = SystemRandom::new();

//         // Generate ECDSA P-256 key pair
//         let pkcs8_bytes = EcdsaKeyPair::generate_pkcs8(&ECDSA_P256_SHA256_FIXED_SIGNING, &rng)
//             .expect("Failed to generate key pair");
//         let key_pair =
//             EcdsaKeyPair::from_pkcs8(&ECDSA_P256_SHA256_FIXED_SIGNING, pkcs8_bytes.as_ref(), &rng)
//                 .expect("Failed to parse key pair");

//         // Extract public key in DER format
//         let public_key_der = key_pair.public_key().as_ref();

//         // Sample authenticator data
//         let authenticator_data = b"example authenticator data";

//         // Sample client data JSON
//         let client_data_json = br#"{
//             "challenge": "test-challenge",
//             "origin": "https://example.com",
//             "type": "webauthn.get"
//         }"#;

//         // Compute client data hash
//         let client_data_hash = ring::digest::digest(&SHA256, client_data_json);

//         // Concatenate authenticator data and client data hash
//         let mut message = Vec::new();
//         message.extend_from_slice(authenticator_data);
//         message.extend_from_slice(client_data_hash.as_ref());

//         // Sign the message
//         let signature = key_pair
//             .sign(&rng, &message)
//             .expect("Failed to sign message");

//         // Tamper with the message
//         let mut tampered_authenticator_data = authenticator_data.to_vec();
//         tampered_authenticator_data[0] ^= 0xFF; // Flip some bits

//         // Verify the signature with tampered data
//         let is_valid = verify_webauthn_response(
//             &tampered_authenticator_data,
//             client_data_hash.as_ref(),
//             signature.as_ref(),
//             public_key_der,
//         );

//         assert!(
//             !is_valid,
//             "The signature should be invalid due to tampered authenticator data."
//         );
//     }
// }
