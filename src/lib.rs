/// Verifies a WebAuthn response signature.
///
/// This function validates the signature of a WebAuthn authentication response by:
///
/// 1. Concatenating the `authenticator_data` and `client_data_hash` to form the message.
/// 2. Verifying the `signature` against the message using the provided `public_key_der`.
///
/// The `public_key_der` should be in DER format and correspond to an ECDSA P-256 public key,
/// as specified in the WebAuthn standard.
///
/// # Arguments
///
/// * `authenticator_data` - The raw bytes of the authenticator data provided by the authenticator.
/// * `client_data_hash` - The SHA-256 hash of the client data JSON.
/// * `signature` - The signature generated by the authenticator.
/// * `public_key_der` - The public key in DER format extracted from the authenticator's attestation data.
///
/// # Returns
///
/// * `true` if the signature is valid.
/// * `false` if the signature is invalid.
///
/// # Example
///
/// ```ignore
/// let authenticator_data = /* ... */;
/// let client_data_hash = /* ... */;
/// let signature = /* ... */;
/// let public_key_der = /* ... */;
///
/// let is_valid = verify_webauthn_response(
///     &authenticator_data,
///     &client_data_hash,
///     &signature,
///     &public_key_der,
/// );
///
/// assert!(is_valid);
/// ```
/// # References
///
/// * [Web Authentication: An API for accessing Public Key Credentials Level 2 - ยง7.2. Verifying an Authentication Assertion](https://www.w3.org/TR/webauthn/#sctn-verifying-assertion)
///
use coset::{CborSerializable, CoseKey};
use p256::ecdsa::VerifyingKey;
use p256::ecdsa::{signature::SignatureEncoding, signature::Verifier, Signature};
use p256::elliptic_curve::PublicKey;
use p256::pkcs8::DecodePublicKey;
use p256::FieldBytes;
use p256::NistP256;
use sha2::{Digest, Sha256};

use passkey::authenticator;

pub fn verify_webauthn_response(
    authenticator_data: &[u8],
    client_data_json: &[u8],
    signature: &[u8],
    credential_public_key_cbor: &[u8],
) -> bool {
    // Step 1: Compute the SHA-256 hash of the client data JSON
    let client_data_hash: [u8; 32] = Sha256::digest(client_data_json).into();

    // Step 2: Concatenate authenticator data and client data hash
    let mut message = Vec::with_capacity(authenticator_data.len() + client_data_hash.len());
    message.extend_from_slice(authenticator_data);
    message.extend_from_slice(&client_data_hash);

    // Step 3: Parse the COSE public key, convert it to DER format, and parse it
    let public_key_cose =
        CoseKey::from_slice(credential_public_key_cbor).expect("Failed to parse COSE public key");
    let public_key_der = authenticator::public_key_der_from_cose_key(&public_key_cose)
        .expect("Failed to convert COSE key to DER format");
    let public_key = PublicKey::<NistP256>::from_public_key_der(&public_key_der)
        .expect("Failed to parse public key DER");
    let verifying_key = VerifyingKey::from(public_key);

    // Step 4: Parse the COSE signature, convert it to DER format, and parse it
    let signature_cose =
        coset::CoseSign1::from_slice(signature).expect("Failed to parse COSE signature");
    // TODO: convert signature to der format
    let signature_der = signature_der_from_cose_signature(&signature_cose);
    let signature = Signature::from_der(&signature_der).expect("Failed to parse signature DER");

    //print all public keys
    println!("Public Key COSE: {:?}", public_key_cose);
    println!("Public Key DER: {:?}", public_key_der);
    println!("Verifying Key: {:?}", verifying_key);

    //print all signatures
    println!("Signature COSE: {:?}", signature_cose);
    println!("Signature DER: {:?}", signature_der);
    println!("Signature: {:?}", signature);

    // Step 5: Verify the signature
    verifying_key
        .verify(&message, &signature)
        .expect("Signature verification failed");

    true
}

pub fn signature_der_from_cose_signature(signature_cose: &coset::CoseSign1) -> Vec<u8> {
    // Assuming the signature is for P-256 (ECDSA), which has 64-byte signatures.
    let signature_bytes = signature_cose.signature.as_slice();
    assert_eq!(
        signature_bytes.len(),
        64,
        "Expected a 64-byte ECDSA signature"
    );

    // Split the 64-byte signature into r and s (each 32 bytes).
    let (r_bytes, s_bytes) = signature_bytes.split_at(32);

    // Convert the byte slices into `FieldBytes<NistP256>`, which is the expected input type.
    let r_field_bytes = FieldBytes::from_slice(r_bytes);
    let s_field_bytes = FieldBytes::from_slice(s_bytes);

    // Create the ECDSA signature from r and s values.
    let signature = Signature::from_scalars(*r_field_bytes, *s_field_bytes)
        .expect("Failed to create ECDSA signature from r and s");

    let signature_der = signature.to_der();

    signature_der.to_vec()
}

// #[cfg(test)]
// mod tests {
//     use super::*;
//     use ring::digest::SHA256;
//     use ring::rand::SystemRandom;
//     use ring::signature::{EcdsaKeyPair, KeyPair, ECDSA_P256_SHA256_FIXED_SIGNING};

//     #[test]
//     fn test_verify_webauthn_response_valid() {
//         let rng = SystemRandom::new();

//         // Generate ECDSA P-256 key pair
//         let pkcs8_bytes = EcdsaKeyPair::generate_pkcs8(&ECDSA_P256_SHA256_FIXED_SIGNING, &rng)
//             .expect("Failed to generate key pair");
//         let key_pair =
//             EcdsaKeyPair::from_pkcs8(&ECDSA_P256_SHA256_FIXED_SIGNING, pkcs8_bytes.as_ref(), &rng)
//                 .expect("Failed to parse key pair");

//         // Extract public key in DER format
//         let public_key_der = key_pair.public_key().as_ref();

//         // Sample authenticator data
//         let authenticator_data = b"example authenticator data";

//         // Sample client data JSON
//         let client_data_json = br#"{
//             "challenge": "test-challenge",
//             "origin": "https://example.com",
//             "type": "webauthn.get"
//         }"#;

//         // Compute client data hash
//         let client_data_hash = ring::digest::digest(&SHA256, client_data_json);

//         // Concatenate authenticator data and client data hash
//         let mut message = Vec::new();
//         message.extend_from_slice(authenticator_data);
//         message.extend_from_slice(client_data_hash.as_ref());

//         // Sign the message
//         let signature = key_pair
//             .sign(&rng, &message)
//             .expect("Failed to sign message");

//         // Verify the signature
//         let is_valid = verify_webauthn_response(
//             authenticator_data,
//             client_data_json.as_ref(),
//             signature.as_ref(),
//             public_key_der,
//         );

//         assert!(
//             is_valid,
//             "The signature should be valid with the generated sample data."
//         );
//     }

//     #[test]
//     fn test_verify_webauthn_response_invalid() {
//         let rng = SystemRandom::new();

//         // Generate ECDSA P-256 key pair
//         let pkcs8_bytes = EcdsaKeyPair::generate_pkcs8(&ECDSA_P256_SHA256_FIXED_SIGNING, &rng)
//             .expect("Failed to generate key pair");
//         let key_pair =
//             EcdsaKeyPair::from_pkcs8(&ECDSA_P256_SHA256_FIXED_SIGNING, pkcs8_bytes.as_ref(), &rng)
//                 .expect("Failed to parse key pair");

//         // Extract public key in DER format
//         let public_key_der = key_pair.public_key().as_ref();

//         // Sample authenticator data
//         let authenticator_data = b"example authenticator data";

//         // Sample client data JSON
//         let client_data_json = br#"{
//             "challenge": "test-challenge",
//             "origin": "https://example.com",
//             "type": "webauthn.get"
//         }"#;

//         // Compute client data hash
//         let client_data_hash = ring::digest::digest(&SHA256, client_data_json);

//         // Concatenate authenticator data and client data hash
//         let mut message = Vec::new();
//         message.extend_from_slice(authenticator_data);
//         message.extend_from_slice(client_data_hash.as_ref());

//         // Sign the message
//         let signature = key_pair
//             .sign(&rng, &message)
//             .expect("Failed to sign message");

//         // Tamper with the message
//         let mut tampered_authenticator_data = authenticator_data.to_vec();
//         tampered_authenticator_data[0] ^= 0xFF; // Flip some bits

//         // Verify the signature with tampered data
//         let is_valid = verify_webauthn_response(
//             &tampered_authenticator_data,
//             client_data_hash.as_ref(),
//             signature.as_ref(),
//             public_key_der,
//         );

//         assert!(
//             !is_valid,
//             "The signature should be invalid due to tampered authenticator data."
//         );
//     }
// }
